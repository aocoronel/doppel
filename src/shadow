#!/usr/bin/env bash

directories=()
PARALLELS=0

RED="$(tput setaf 196)"
GREEN="$(tput setaf 82)"
BLUE="$(tput setaf 87)"
ORANGE="$(tput setaf 166)"
RESET=$(tput sgr0)

function help() {
  cat <<EOF
$(_text "$BLUE" "Run command in another location")

$(_text "$BLUE" "Usage:")
  shadow FLAG <FLAG_INPUT> COMMANDS

$(_text "$BLUE" "Flags:")
  -h      Displays this message and exits
EOF
}

run_commands() {
  local result=0
  local i=0
  local curr_dir

  curr_dir=$PWD
  [[ "$PWD" =~ $HOME ]] && curr_dir=$(sed "s|$HOME|~|" <<<"$PWD")
  [ -n "$VERBOSE" ] && echo "Running command in ${BLUE}$curr_dir${RESET}"

  while [[ $i -lt ${#commands[@]} ]]; do
    local cmd=()

    # Collect current command
    while [[ ${commands[$i]} != "AND" && ${commands[$i]} != "NOT" && $i -lt ${#commands[@]} ]]; do
      cmd+=("${commands[$i]}")
      ((i++))
    done

    # Run current command
    #
    [ -n "$VERBOSE" ] && echo "${GREEN}Running:${RESET} ${BLUE}[$op]${RESET} ${ORANGE}${cmd[*]}${RESET}"
    if [[ -z "$DEBUG" ]]; then
      "${cmd[@]}"
      result=$?
    else
      result=0
    fi

    # Check next logical operator
    if [[ $i -lt ${#commands[@]} ]]; then
      local op="${commands[$i]}"
      ((i++))

      if [[ $op == "AND" && $result -ne 0 ]]; then
        tmp_i=$((i + 1))
        echo "Previous command failed. Skipping ${commands[$tmp_i]}."
        # Skip next command
        while [[ ${commands[$i]} != "AND" && ${commands[$i]} != "NOT" && $i -lt ${#commands[@]} ]]; do
          ((i++))
        done
      elif [[ $op == "NOT" && $result -eq 0 ]]; then
        [ -n "$VERBOSE" ] && {
          tmp_i=$((i + 1))
          echo "Previous command succeeded. Skipping ${commands[$tmp_i]}."
        }
        # Skip next command
        while [[ ${commands[$i]} != "AND" && ${commands[$i]} != "NOT" && $i -lt ${#commands[@]} ]]; do
          ((i++))
        done
      fi
    fi
  done
}

main() {
  if [ "$PARALLELS" -gt 0 ]; then
    for directory in "${directories[@]}"; do
      if [[ ! -d "$directory" ]]; then
        echo "Directory '$directory' not found."
        continue
      fi
      pushd "$directory" >/dev/null || return 1
      run_commands &
      popd >/dev/null || return 1
      while [ "$(jobs | wc -l)" -eq "$PARALLELS" ]; do
        wait -n
      done
    done
  else
    for directory in "${directories[@]}"; do
      if [[ ! -d "$directory" ]]; then
        echo "Directory '$directory' not found."
        continue
      fi
      pushd "$directory" >/dev/null || return 1
      run_commands
      popd >/dev/null || return 1
    done
  fi
}

case "$1" in
--dry)
  shift
  DEBUG=1
  ;;
--verbose)
  shift
  VERBOSE=1
  ;;
esac

while getopts ":h-j:" opt; do
  case "$opt" in
  h)
    help
    exit 0
    ;;
  -)
    break
    ;;
  j)
    PARALLELS=$OPTARG
    ;;
  ?)
    echo "${RED}ERROR:${RESET} Invalid option '-$OPTARG'" >&2
    exit 1
    ;;
  esac
done

shift $((OPTIND - 1))

while [ "$1" != "-exec" ]; do
  [ -z "$1" ] && {
    echo "Command not found."
    exit 1
  }
  directories+=("$1")
  shift
done

shift
commands=("$@")

main
