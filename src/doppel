#!/usr/bin/env bash

directories=()
PARALLELS=0

RED="$(tput setaf 196)"
GREEN="$(tput setaf 82)"
BLUE="$(tput setaf 87)"
ORANGE="$(tput setaf 166)"
RESET=$(tput sgr0)

function _text() {
  local color text reset
  color=$1
  text=$2
  reset=$(tput sgr0)

  echo -e "${color}${text}${reset}"
}

function help() {
  cat <<EOF
$(_text "$BLUE" "Run any command in another location concurrently")

$(_text "$BLUE" "Usage:")
  shadow [OPTION] [DIR] -exec [COMMAND]

$(_text "$BLUE" "Options:")
  -exec      Specify command to be used
  -h         Displays this message and exits
  -j <JOBS>  Run with async. Default is 0.
  -v         Display the program version.
EOF
}

function version() {
  echo "1.0.0"
}

executeCommands() {
  local result=0
  local i=0
  local curr_dir

  curr_dir=$PWD
  [[ "$PWD" =~ $HOME ]] && curr_dir=$(sed "s|$HOME|~|" <<<"$PWD")
  [ -n "$VERBOSE" ] && echo "Running command in ${BLUE}$curr_dir${RESET}"

  while [[ $i -lt ${#commands[@]} ]]; do
    local cmd=()

    # Collect current command
    while [[ ${commands[$i]} != "AND" && ${commands[$i]} != "NOT" && $i -lt ${#commands[@]} ]]; do
      cmd+=("${commands[$i]}")
      ((i++))
    done

    # Run current command
    #
    [ -n "$VERBOSE" ] && echo "${GREEN}Running:${RESET} ${BLUE}[$op]${RESET} ${ORANGE}${cmd[*]}${RESET}"
    if [[ -z "$DEBUG" ]]; then
      "${cmd[@]}"
      result=$?
    else
      result=0
    fi

    # Check next logical operator
    if [[ $i -lt ${#commands[@]} ]]; then
      local op="${commands[$i]}"
      ((i++))

      if [[ $op == "AND" && $result -ne 0 ]]; then
        tmp_i=$((i + 1))
        echo "Previous command failed. Skipping ${commands[$tmp_i]}."
        # Skip next command
        while [[ ${commands[$i]} != "AND" && ${commands[$i]} != "NOT" && $i -lt ${#commands[@]} ]]; do
          ((i++))
        done
      elif [[ $op == "NOT" && $result -eq 0 ]]; then
        [ -n "$VERBOSE" ] && {
          tmp_i=$((i + 1))
          echo "Previous command succeeded. Skipping ${commands[$tmp_i]}."
        }
        # Skip next command
        while [[ ${commands[$i]} != "AND" && ${commands[$i]} != "NOT" && $i -lt ${#commands[@]} ]]; do
          ((i++))
        done
      fi
    fi
  done
}

run_commands() {
  local directory=$1
  if [[ ! -d "$directory" ]]; then
    echo "Directory '$directory' not found."
    return 1
  fi
  pushd "$directory" >/dev/null || return 1
  if [ "$PARALLELS" -gt 0 ]; then
    executeCommands &
  else
    executeCommands
  fi
  popd >/dev/null || return 1
  if [ "$PARALLELS" -gt 0 ]; then
    while [ "$(jobs | wc -l)" -eq "$PARALLELS" ]; do
      wait -n
    done
  fi
}

main() {
  for directory in "${directories[@]}"; do
    if [ -f "$directory" ]; then
      cat "$directory" | while IFS= read -r dir; do
        run_commands "$dir"
      done
    else
      run_commands "$directory"
    fi
  done
}

case "$1" in
--dry)
  shift
  DEBUG=1
  VERBOSE=1
  ;;
--verbose)
  shift
  VERBOSE=1
  ;;
esac

while getopts ":h-j:" opt; do
  case "$opt" in
  h)
    help
    exit 0
    ;;
  -)
    break
    ;;
  j)
    PARALLELS=$OPTARG
    ;;
  ?)
    echo "${RED}ERROR:${RESET} Invalid option '-$OPTARG'" >&2
    exit 1
    ;;
  esac
done

shift $((OPTIND - 1))

while [ "$1" != "-exec" ]; do
  [ -z "$1" ] && {
    echo "Command not found."
    exit 1
  }
  directories+=("$1")
  shift
done

shift
commands=("$@")

main
